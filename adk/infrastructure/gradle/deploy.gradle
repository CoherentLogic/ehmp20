import groovy.json.JsonBuilder
import groovy.json.JsonOutput

configurations {
  antform
}

buildscript {
  repositories {
    maven { url "https://store.vistacore.us/nexus/content/groups/public" }
  }

  dependencies {
    classpath 'net.java.dev.jna:jna:4.0.0'
  }
}

dependencies {
  antform group: 'com.sardak', name: 'antform', version: '2.0'
}

def deployGroup = 'Deployment/Vagrant'

def projectInfoCollection = [
  [
    taskNamePart : 'adk',
    dependsOn : [ ':production:build' ],
    vagrantDir : "${rootDir}/../infrastructure/vagrant/virtualbox/adk",
    vagrantEnvVarsLocal : [ 'ADK_DEV_DIR' : "${rootDir}/../product/production" ],
    vagrantEnvVarsVersion : [ 'ADK_VERSION' : "Latest" ],
    partOfTestEnv : true,
    partOfBackend : true,
    devDeploy : true,
    testDeploy : true
  ],
]

projectInfoCollection.each { projectInfo ->
  ext.set("deploy${projectInfo['taskNamePart']}DevFlag", false)
  ext.set("deploy${projectInfo['taskNamePart']}Flag", false)
  ext.set("start${projectInfo['taskNamePart']}Flag", false)
  ext.set("stop${projectInfo['taskNamePart']}Flag", false)
  ext.set("reload${projectInfo['taskNamePart']}Flag", false)
  ext.set("destroy${projectInfo['taskNamePart']}Flag", false)
  ext.set("snapshot${projectInfo['taskNamePart']}Flag", false)
  ext.set("restore${projectInfo['taskNamePart']}Flag", false)
  ext.set("ssh${projectInfo['taskNamePart']}Flag", false)
}
ext.set("deployForTesterFlag", false)
ext.set("deployBackendDevFlag", false)
ext.set("deployBackendFlag", false)
ext.set("destroyBackendDevFlag", false)
ext.set("stopBackendDevFlag", false)
ext.set("startBackendDevFlag", false)
ext.set("destroyAllFlag", false)
ext.set("stopAllFlag", false)
ext.set("startAllFlag", false)

allprojects  {

  if (tasks.grep{it.name == 'deployFrontendDev'}.size() == 0) {

    projectInfoCollection.each { projectInfo ->

      if (projectInfo['devDeploy']) {
        task "deploy${projectInfo['taskNamePart']}Dev"(dependsOn:projectInfo['dependsOn']) {
          group deployGroup
          description "Locally deploys ${projectInfo['taskNamePart']} server from locally built binaries."
          ext{}
          doLast {
            if (rootProject."deploy${projectInfo['taskNamePart']}DevFlag" == false) {
              rootProject."deploy${projectInfo['taskNamePart']}DevFlag" = true

              FileTree tree = fileTree(dir: new File(project(':').projectDir.parentFile, 'infrastructure/chef/cookbooks'))
              deployToVagrantBox(projectInfo['vagrantDir'], projectInfo['vagrantEnvVarsLocal'])

            }
          }
        }
      }

      if (projectInfo['testDeploy']) {
        task "deploy${projectInfo['taskNamePart']}" {
          group deployGroup
          description "Locally deploys ${projectInfo['taskNamePart']} server from Nexus."
          ext{}
          doLast {
            if (rootProject."deploy${projectInfo['taskNamePart']}Flag" == false) {
              rootProject."deploy${projectInfo['taskNamePart']}Flag" = true
              deployNexusSource(projectInfo['vagrantDir'], projectInfo['vagrantEnvVarsVersion'])
            }
          }
        }
      }

      task "start${projectInfo['taskNamePart']}" {
        group deployGroup
        description "Starts the local ${projectInfo['taskNamePart']} server."
        ext{}
        doLast {
          if (rootProject."start${projectInfo['taskNamePart']}Flag" == false) {
            rootProject."start${projectInfo['taskNamePart']}Flag" = true
            upVagrantBox(projectInfo['vagrantDir'], projectInfo['vagrantEnvVarsLocal'], true)
          }
        }
      }

      task "stop${projectInfo['taskNamePart']}" {
        group deployGroup
        description "Stops the local ${projectInfo['taskNamePart']} server."
        ext{}
        doLast {
          if (rootProject."stop${projectInfo['taskNamePart']}Flag" == false) {
            rootProject."stop${projectInfo['taskNamePart']}Flag" = true
            haltVagrantBox(projectInfo['vagrantDir'])
          }
        }
      }

      task "reload${projectInfo['taskNamePart']}" {
        group deployGroup
        description "Reloads (restarts and applies changes from Vagantfile) to the local ${projectInfo['taskNamePart']} server."
        ext{}
        doLast {
          if (rootProject."reload${projectInfo['taskNamePart']}Flag" == false) {
            rootProject."reload${projectInfo['taskNamePart']}Flag" = true
            reloadVagrantBox(projectInfo['vagrantDir'])
          }
        }
      }

      task "destroy${projectInfo['taskNamePart']}" {
        group deployGroup
        description "Destroys local ${projectInfo['taskNamePart']} server."
        ext{}
        doLast {
          if (rootProject."destroy${projectInfo['taskNamePart']}Flag" == false) {
            rootProject."destroy${projectInfo['taskNamePart']}Flag" = true
            destroyVagrantBox(projectInfo['vagrantDir'])
          }
        }
      }

      task "snapshot${projectInfo['taskNamePart']}" {
        group deployGroup
        description "Takes a snapshot of the local ${projectInfo['taskNamePart']} server."
        ext{}
        doLast {
          if (rootProject."snapshot${projectInfo['taskNamePart']}Flag" == false) {
            rootProject."snapshot${projectInfo['taskNamePart']}Flag" = true
            snapshotVagrantBox(projectInfo['vagrantDir'])
          }
        }
      }

      task "restore${projectInfo['taskNamePart']}" {
        group deployGroup
        description "Restores to the last snapshot of the local ${projectInfo['taskNamePart']} server."
        ext{}
        doLast {
          if (rootProject."restore${projectInfo['taskNamePart']}Flag" == false) {
            rootProject."restore${projectInfo['taskNamePart']}Flag" = true
            restoreVagrantBox(projectInfo['vagrantDir'])
          }
        }
      }

      task "ssh${projectInfo['taskNamePart']}" {
        group deployGroup
        description "Opens SSH (Secure Shell) session to the local ${projectInfo['taskNamePart']} server."
        ext{}
        doLast {
          def os_version = "sw_vers".execute().text.split("\n").find{ l -> l.contains("ProductVersion") }.split(/\s+/)[1]

          if( os_version.contains("10.9") ){
            println '''
===============================================================================
The "gradle ssh*" tasks are unsupported on Mac OSX Mavericks (10.9.x). You will
need to go to the individual directories where the Vagrantfile for the machine
that you are interested in resides and "vagrant ssh" into it.

For example, if you want to "gradle sshMongoDB", execute the following:
  $ cd ~/Projects/vistacore/adk/infrastructure/vagrant/virtualbox/mongodb

  $ vagrant ssh
    ...
===============================================================================
'''
            throw new StopExecutionException()
          }
          else{
            if (rootProject."ssh${projectInfo['taskNamePart']}Flag" == false) {
              rootProject."ssh${projectInfo['taskNamePart']}Flag" = true
              sshVagrantBox(projectInfo['machineName'], projectInfo['vagrantDir'])
            }
          }
        }
      }
    }

  }
}

def vagrantBin(){
  def retval = '/usr/bin/vagrant'

  if( System.properties['os.name'].toLowerCase().contains('windows')) {
    retval = 'C:/opscode/chef/embedded/bin/vagrant.bat'
  }

  return retval
}

def upVagrantBox(vagrantDir, envVars, boolean berkscache = false) {
  exec {
    executable = vagrantBin()
    args = ['up', '--no-provision']
    if (berkscache) {
      args << '-bc'
    }
    workingDir vagrantDir
    environment(envVars)
  }
}

import com.sun.jna.*;

public interface Posix extends Library {
  public int execlp(String path, String... args)
  public int chdir(String path)
}

def sshVagrantBox(vagrantDir){
  Posix posix = (Posix) Native.loadLibrary("c", Posix.class);
  posix.chdir(vagrantDir)
  posix.execlp("vagrant", "vagrant", "ssh")
}

def executeVagrant(vagrantDir, command) {
  exec {
    executable = vagrantBin()
    args = command
    workingDir vagrantDir
  }
}

def haltVagrantBox(vagrantDir) {
  executeVagrant(vagrantDir, ["halt"])
}

def reloadVagrantBox(vagrantDir) {
  executeVagrant(vagrantDir, ["reload","--no-provision"])
}

def destroyVagrantBox(vagrantDir) {
  executeVagrant(vagrantDir, ["destroy","-f"])
}

def snapshotVagrantBox(vagrantDir) {
  executeVagrant(vagrantDir, ["sandbox", "on"])
  executeVagrant(vagrantDir, ["sandbox", "commit"])
}

def restoreVagrantBox(vagrantDir) {
  executeVagrant(vagrantDir, ["sandbox", "rollback"])
}

def deployToVagrantBox(vagrantDir, envVars) {
  upVagrantBox(vagrantDir, envVars)

  exec {
    executable = vagrantBin()
    args = ['provision']
    workingDir vagrantDir
    environment(envVars)
  }
}

def deployNexusSource(vagrantDir, envVars) {
  new ByteArrayOutputStream().withStream { os ->
    exec {
      executable = vagrantBin()
      args = ['status']
      workingDir vagrantDir
      standardOutput = os
    }

    def outputAsString = os.toString()
    if(outputAsString.contains("running (virtualbox)")) {
      exec {
        executable = vagrantBin()
        args = ['ssh', '-c', '"mount"']
        workingDir vagrantDir
        standardOutput = os
      }

      def mountOutput = os.toString()
      if(mountOutput.contains("/var/www/adk type vboxsf")) {
        println "ADK local deployment found. Loading Nexus deployment configurations."

        exec {
          executable = vagrantBin()
          args = ['reload', '--provision']
          workingDir vagrantDir
        }
      } else {
        deployToVagrantBox(vagrantDir, envVars)
      }
    } else {
      deployToVagrantBox(vagrantDir, envVars)
    }
  }
}

def getLocalWarFile() {
  def buildVersion = '0.7-S54'
  /* def buildVersion = ${project(':production').version} */
  def localWarFile = "${rootDir}/production/hmp-main/build/libs/hmp-main-${buildVersion}.war"
  return localWarFile
}

def askUserToChooseBackendBuild(String artifactVersionName) {
  def protocol = 'https://'
  def serverName = 'build.vistacore.us'
  def port = ''
  def jobName = 'adk-dev-build-next'
  def resultSetSize = 20
  def restEndPointBuildList = "${protocol}${serverName}${port}/job/${jobName}/api/xml?depth=1&xpath=(/*/build[result='SUCCESS'])[position()<=${resultSetSize}]/action/parameter[name='${artifactVersionName}']/value&wrapper=builds"

  def slurper = new XmlSlurper()
  def buildList = slurper.parse(restEndPointBuildList)
  def goodBuilds = []

  buildList.value.each {
    goodBuilds.add(it.text().replace(jobName, '').trim())
  }

  def goodBuildsFlat = ''
  def count = 0
  goodBuilds.unique().sort{ it.split('\\.')[3].toInteger() }.reverse().each {
    if (count >= 6) return
    if (goodBuildsFlat == ''){
        goodBuildsFlat = it
    }else{
        goodBuildsFlat = goodBuildsFlat + "," + it
    }
    count += 1
  }
  ant.taskdef(
    name:"antform",
    classname: "com.sardak.antform.AntForm",
    classpath: configurations.antform.asPath
  )

  ant.antform(title: "Choose Which Backend eHMP Build to Deploy"){
    ant.label("Choose a backend REST build")
    ant.radioSelectionProperty(label: "Builds: ", property: "buildChosen", values: "${goodBuildsFlat}")
  }
  def buildNumber = ant.project.properties.buildChosen;

  return buildNumber
}

def getVagrantKey(){
  def possibleLocations = [
    System.getProperty("user.home") + '/.vagrant.d/insecure_private_key',
    System.getenv()["VAGRANT_HOME"] + '/insecure_private_key'
  ]

  def key = possibleLocations.find{ f -> new File(f).exists() }
  if( key == null ){
    throw new Exception("Could not find the vagrant ssh key in the following locations: " + possibleLocations)
  }

  return new File(key).getCanonicalPath()
}

def needsUpdate(tree, flagFile){
  if(!flagFile.exists()) {
    return true
  }
  def max = 0
  tree.each{ if(it.lastModified() > max){ max = it.lastModified()} }
  return flagFile.lastModified() < max
}
